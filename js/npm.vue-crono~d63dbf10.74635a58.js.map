{"version":3,"sources":["webpack:///./node_modules/vue-crono/index.js"],"names":["mapOrSingle","obj","fn","constructor","Array","map","createTimer","cron","this","_cron","method","timerRunning","autoStart","timer","setInterval","$options","methods","call","lastInvocation","Date","time","mixin","undefined","bind","$cron","stop","locatedCronMethod","clearInterval","Error","start","restart","currentDate","elapsed","setTimeout","prop"],"mappings":"0HAAA,wCAAMA,EAAc,SAASC,EAAKC,GAC9B,OAAGD,EAAIE,cAAgBC,MACZF,EAAGD,GAGHA,EAAII,IAAIH,IAIjBI,EAAc,SAASC,GACzBC,KAAKC,MAAQD,KAAKC,OAAS,GAC3B,MAAMC,EAASH,EAAKG,OAEjBF,KAAKC,MAAMC,IAAWF,KAAKC,MAAMC,GAAQC,gBAEtB,IAAnBJ,EAAKK,UACJJ,KAAKC,MAAMC,GAAU,CAAEC,cAAc,GAGrCH,KAAKC,MAAMC,GAAU,CACjBG,MAAOC,YAAY,KACfN,KAAKO,SAASC,QAAQN,GAAQO,KAAKT,MACnCA,KAAKC,MAAMC,GAAQQ,gBAAmB,IAAIC,MAC3CZ,EAAKa,MACRT,cAAc,EACdS,KAAMb,EAAKa,KACXF,gBAAkB,IAAIC,QAK5BE,EAAQ,CACV,eAC2BC,IAAvBd,KAAKO,SAASR,MACdP,EAAYQ,KAAKO,SAASR,KAAMD,EAAYiB,KAAKf,OAGrDA,KAAKgB,MAAQ,CACTC,KAAMf,IACF,IAAIgB,GAAoB,EAWxB,GAVA1B,EAAYQ,KAAKO,SAASR,KAAMA,IAC5B,GAAIA,EAAKG,SAAWA,EAAO,CAGvB,GAFAgB,GAAoB,GAEhBlB,KAAKC,MAAMF,EAAKG,QAAQC,aAAc,OAE1CgB,cAAcnB,KAAKC,MAAMF,EAAKG,QAAQG,OACtCL,KAAKC,MAAMF,EAAKG,QAAQC,cAAe,MAG1Ce,EACD,MAAM,IAAIE,MAAM,gBAAgBlB,6CAGxCmB,MAAOnB,IACH,IAAIgB,GAAoB,EAOxB,GANA1B,EAAYQ,KAAKO,SAASR,KAAMA,IACxBA,EAAKG,SAAWA,IAChBgB,GAAoB,EACpBpB,EAAYW,KAAKT,KAAM,IAAKD,EAAMK,WAAW,QAGhDc,EACD,MAAM,IAAIE,MAAM,gBAAgBlB,6CAGxCoB,QAASpB,IACLF,KAAKgB,MAAMC,KAAKf,GAChBF,KAAKgB,MAAMK,MAAMnB,IAErBU,KAAM,CAACV,EAAQU,KACX,MAAMW,GAAgB,IAAIZ,KAEtBX,KAAKC,MAAMC,GAAQC,eACnBH,KAAKC,MAAMC,GAAQQ,eAAiBa,GAExC,MAAMC,EAAUD,EAAcvB,KAAKC,MAAMC,GAAQQ,eAEjDV,KAAKgB,MAAMC,KAAKf,GAEbsB,EAAUZ,GACTZ,KAAKO,SAASC,QAAQN,GAAQO,KAAKT,MACnCF,EAAYW,KAAKT,KAAM,CAAEE,SAAQU,UAGjCa,WAAW,KACPzB,KAAKO,SAASC,QAAQN,GAAQO,KAAKT,MACnCF,EAAYW,KAAKT,KAAM,CAAEE,SAAQU,UAClCA,EAAOY,MAKtB,gBACA,IAAI,MAAME,KAAQ1B,KAAKC,WACKa,IAArBd,KAAKC,MAAMyB,IACVP,cAAcnB,KAAKC,MAAMyB,GAAMrB","file":"js/npm.vue-crono~d63dbf10.74635a58.js","sourcesContent":["const mapOrSingle = function(obj, fn){\r\n    if(obj.constructor !== Array){\r\n        return fn(obj);\r\n    }\r\n    else{\r\n        return obj.map(fn);\r\n    }\r\n};\r\n\r\nconst createTimer = function(cron){\r\n    this._cron = this._cron || {};\r\n    const method = cron.method;\r\n\r\n    if(this._cron[method] && this._cron[method].timerRunning) return;\r\n\r\n    if(cron.autoStart === false){\r\n        this._cron[method] = { timerRunning: false };\r\n    }\r\n    else{\r\n        this._cron[method] = {\r\n            timer: setInterval(() => {\r\n                this.$options.methods[method].call(this);\r\n                this._cron[method].lastInvocation = + new Date();\r\n            }, cron.time),\r\n            timerRunning: true,\r\n            time: cron.time,\r\n            lastInvocation: + new Date()\r\n        };\r\n    }\r\n};\r\n\r\nconst mixin = {\r\n    mounted(){\r\n    if (this.$options.cron !== undefined){\r\n        mapOrSingle(this.$options.cron, createTimer.bind(this));\r\n    }\r\n\r\n    this.$cron = {\r\n        stop: method => {\r\n            let locatedCronMethod = false;\r\n            mapOrSingle(this.$options.cron, cron => {\r\n                if (cron.method === method){\r\n                    locatedCronMethod = true;\r\n\r\n                    if(!this._cron[cron.method].timerRunning) return;\r\n\r\n                    clearInterval(this._cron[cron.method].timer);\r\n                    this._cron[cron.method].timerRunning = false;\r\n                }\r\n            });\r\n            if (!locatedCronMethod){\r\n                throw new Error(`Cron method '${method}' does not exist and cannot be stopped.`);\r\n            }\r\n        },\r\n        start: method => {\r\n            let locatedCronMethod = false;\r\n            mapOrSingle(this.$options.cron, cron => {\r\n                if (cron.method === method){\r\n                    locatedCronMethod = true;\r\n                    createTimer.call(this, { ...cron, autoStart: true });\r\n                }\r\n            });\r\n            if (!locatedCronMethod){\r\n                throw new Error(`Cron method '${method}' does not exist and cannot be started.`);\r\n            }\r\n        },\r\n        restart: method =>{\r\n            this.$cron.stop(method);\r\n            this.$cron.start(method);\r\n        },\r\n        time: (method, time) => {\r\n            const currentDate = + new Date();\r\n\r\n            if(!this._cron[method].timerRunning){\r\n                this._cron[method].lastInvocation = currentDate;\r\n            }\r\n            const elapsed = currentDate - this._cron[method].lastInvocation;\r\n\r\n            this.$cron.stop(method);\r\n\r\n            if(elapsed > time){\r\n                this.$options.methods[method].call(this);\r\n                createTimer.call(this, { method, time});\r\n            }\r\n            else{\r\n                setTimeout(() => {\r\n                    this.$options.methods[method].call(this);\r\n                    createTimer.call(this, { method, time});\r\n                }, time - elapsed);\r\n            }\r\n        }\r\n    };\r\n},\r\n    beforeDestroy(){\r\n    for(const prop in this._cron){\r\n        if(this._cron[prop] !== undefined){\r\n            clearInterval(this._cron[prop].timer);\r\n        }\r\n    }\r\n}\r\n};\r\n\r\nconst cron = Vue => {\r\n    Vue.mixin(mixin);\r\n};\r\n\r\nexport default cron;\r\nexport { mixin as crono };"],"sourceRoot":""}